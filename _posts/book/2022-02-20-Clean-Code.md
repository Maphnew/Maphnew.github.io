---
title: "[Book] Clean Code"
date: 2022-02-20 21:25:00
categories:
  - Book
tags:
  - [Book]

toc: true
toc_sticky: true
---

# 클린 코드

애자일 소프트웨어 장인 정신

<small>저자: 로버트 C. 마틴</small>

# 1. 깨끗한 코드

page 1~20

### 깨끗한 코드라는 예술

깨끗한 코드를 작성하는 프로그래머는 빈 캔버스를 우아한 작품으로 바꿔가는 화가와 같다.

### 비야네 스트롭스트룹

우하하고 효율적인 코드

### 그래디 부치

가독성

### 큰 데이브 토마스

의미 있는 이름

### 마이클 페더스

누군가 주의 깊게 짰다는 느낌을 준다.

### 론 제프리스

중복이 없다.

### 워드 커닝햄

짐작했던 기능을 수행한다.

### 우리들 생각

이 책은 우리 오브젝트 멘토 진영이 생각하는 깨끗한 코드를 설명한다.

### 우리는 저자다

새 코드를 짜면서 우리는 끊임없이 기존 코드를 읽는다.

### 보이스카우트 규칙

캠프장은 처음 왔을 때보다 더 깨끗하게 해놓고 떠나라.

### 프리퀄과 원칙

이 책은 Agile Software Development: Principles, Patterns, and Practices의 프리퀄`prequel`이다.

이 책에서는 SRP`Single Responsibility Principle` , OCP `Open Closed Principle`, DIP`Dependency Inversion Principle` 와 같은 설계 원칙을 산발적으로 거론한다.

### 결론

예술가가 되기 위한 책은 없다. 나머지는 여러분에게 달렸다.

# 2. 의미 있는 이름

page 21~38

### 의도를 분명히 밝혀라

`int d;`

### 그릇된 정보를 피하라

O, L

### 의미 있게 구분하라

`zork` vs `theZork`

### 발음하기 쉬운 이름을 사용하라

프로그래밍은 사회 활동이기 떄문이다.

### 검색하기 쉬운 이름을 사용하라

`WORK_DAYS_PER_WEEK`

### 인코딩을 피하라

- 헝가리식 표기법
- 멤버 변수 접두어
- 인터페이스 클래스와 구현 클래스

### 자신의 기억력을 자랑하지 마라

### 클래스 이름

명사나 명사구가 적합하다. 동사는 사용하지 않는다.

### 메서드 이름

동사나 동사구가 적합하다.

### 기발한 이름은 피하라

특정 문화에서만 사용하는 농담은 피하는 편이 좋다.

### 한 개념에 한 단어를 사용하라

fetch, get, retrieve

### 말장난을 하지 마라

한 단어를 두 가지 목적으로 사용하지 마라.

### 해법 영역에서 가져온 이름을 사용하라

전산 용어, 알고리즘 이름, 패턴 이름, 수학 용어 등

### 문제 영역에서 가져온 이름을 사용하라

### 의미 있는 맥락을 추가하라

### 불필요한 맥락을 없애라

### 마치면서

좋은 이름을 선택하려면 설명 능력이 뛰어나야 하고 문화적인 배경이 같아야 한다.

이것이 제일 어렵다. 좋은 이름을 선택하는 능력은 교육 문제다.

# 3. 함수

page 39 ~ 66

루틴과 하위 루틴

프로그램 - 하위 프로그램 - 함수

가장 기본적인 단위가 함수

함수를 잘 만드는 법 소개하는 장

### 작게 만들어라!

함수를 만드는 규칙은 첫번째도 ‘작게!’, 두번째도 ‘작게!’다. 2~4줄 정도면 적당하다.

#### 블록과 들여쓰기

if문 등에 들어가는 블록은 한 줄이어야 한다.

### 한 가지만 해라!

함수는 한 가지를 해야 한다. 그 한 가지를 잘 해야 한다. 그 한 가지만을 해야 한다.

#### 함수 내 섹션

한 가지 작업만 하는 함수는 자연스럽게 섹션으로 나누기 어렵다.

### 함수 당 추상화 수준은 하나로!

근본 개념과 세부사항을 뒤섞기 시작하면, 깨어진 창문처럼 사람들이 함수에 세부사항을 점점 더 추가한다.

#### 위에서 아래로 코드 읽기: 내려가기 규칙

한 함수 다음에는 **`추상화 수준`**이 한 단계 낮은 함수가 온다. 즉, 위에서 아래로 프로그램을 읽으면 함수 추상화 수준이 한 번에 한 단계 씩 낮아진다.

### Switch 문

switch 문을 저차원 클래스에 숨기고 절대로 반복하지 않는 방법은 있다. 물론 다형성`polymorphism` 을 이용한다. page 48

### 서술적인 이름을 사용하라!

서술적인 이름을 사용하면 개발자 머릿속에서도 설계가 뚜렷해지므로 코드를 개선하기 쉬워진다.

`includeSetupAndTeardownPages`, `includeSetupPages`, `includeSuiteSetupPage`, `includeSetupPage`

### 함수 인수

이상적인 인수 개수는 0개다.

#### 많이 쓰는 단항 형식

함수에 인수 1개를 넘기는 이유로 가장 흔한 경우는 두 가지다.

1. 인수에 질문을 던지는 경우
2. 이벤트 함수

#### 플래그 인수

추하다.

#### 이항 함수

좌표의 경우

#### 삼항 함수

주춤하게 된다.

#### 인수 객체

변수를 묶어 넘기면 이름을 붙여야 하므로 결국은 개념을 표현하게 된다.

#### 인수 목록

때로는 인수 개수가 가변적인 함수도 필요하다.

#### 동사와 키워드

`writeField(name)`

`assertExpectedEqualsActual(expected, actual)`

### 부수 효과를 일으키지 마라!

부수 효과는 거짓말이다.

#### 출력 인수

`appendFooter(s);`

`report.appendFooter();`

### 명령과 조회를 분리하라!

함수는 뭔가를 수행하거나 뭔가에 답하거나 둘 중 하나만 해야 한다.

### 오류 코드보다 예외를 사용하라!

try - catch

#### Try/Catch 블록 뽑아내기

try/catch 블록을 별도 함수로 뽑아내는 편이 좋다.

오류 처리도 한 가지 작업이다.

함수가 한 가지 작업만 하는 것과 같이 오류 처리 함수도 한 가지 작업을 한다.

#### Error.java 의존성 자석

어디선가 오류 코드를 정의하면 자석과 같이 import해 사용한다.

그래서 정의된 코드 변경이 어려워진다. 그래서 기존 오류 코드를 재사용한다.

### 반복하지 마라!

모든 악의 근원이다.

### 구조적 프로그래밍

함수는 return문이 1개여야 한다.

### 함수를 어떻게 짜죠?

글짓기와 비슷하다.

초안은 길고 복잡하다.

단위 테스트 케이스도 만든다.

코드를 다듬고, 함수를 만들고, 이름을 바꾸고, 중복을 제거한다. 메서드를 줄이고 순서를 바꾼다. 때로는 전체 클래스를 쪼개기도 한다.

이 와중에도 단위 테스트를 통과한다.

### 결론

대가 프로그래머는 시스템을 (구현할) 프로그램이 아니라 (풀어갈) 이야기로 여긴다.

좀 더 풍부하고 좀 더 표현력이 강한 언어를 만들어 이야기를 풀어간다.

# 4. 주석

주석은 나쁜 코드를 보완하지 못한다

코드로 의도를 표현하라!

### 좋은 주석

법적인 주석

정보를 제공하는 주석

의도를 설명하는 주석

의미를 명료하게 밝히는 주석

결과를 경고하는 주석

TODO 주석

중요성을 강조하는 주석

공개 API에서 Javadocs

### 나쁜 주석

나머지 모두 나쁜 주석이다.

# 5. 형식 맞추기 formatting

형식을 깔끔하게 맞춰 코드를 짜야 한다.

간단한 규칙을 정하고 그 규칙을 따라야 한다.

자동으로 적용하는 도구를 활용한다.

## 형식을 맞추는 목적

의사소통은 전문 개발자의 일차적인 의무다.

## 적절한 행 길이를 유지하라

일반적으로 큰 파일보다 작은 파일이 이해하기 쉽다.

### 신문 기사처럼 작성하라

이름은 간단하면서도 설명이 가능하게 짓는다.

아래로 내려갈수록 의도를 세세하게 묘사한다.

### 개념은 빈 행으로 분리하라

생각 사이는 빈 행을 넣어 분리해야 마땅하다. 새로운 개념을 시작한다는 시각적 단서다.

### 세로 밀집도

세로 밀집도는 연관성을 의미한다.

### 수직 거리

서로 밀접한 개념은 세로로 가까이 둬야 한다.

### 세로 순서

호출되는 함수를 호출하는 함수보다 나중에 배치한다. 🎃

## 가로 형식 맞추기

프로그래머는 명백하게 짧은 행을 선호한다.

### 가로 공백과 밀집도

밀접한 개념과 느슨한 개념을 표현한다.

### 가로 정렬

인위적은 가로 정렬은 유용하지 못하다. 변수 유형은 무시하고 변수 이름부터 읽게 된다.

### 들여쓰기

Outline은 범위scope이다.

### 가짜 범위

## 팀 규칙

팀에 속한다면 자신이 선호해야 할 규칙은 바로 팀 규칙이다.

## 밥 아저씨의 형식 규칙

# 6. 객체와 자료 구조

page 151

## 자료 추상화

자료를 세세하게 공개하기보다는 추상적은 개념으로 표현하는 편이 좋다.  
개발자는 객체가 포함하는 자료를 표현할 가장 좋은 방법을 심각하게 고민해야 한다.

## 자료/객체 비대칭

객체는 추상화 뒤로 자료를 숨긴 채 자료를 다루는 함수만 공개한다.
자료 구조는 자료를 그대로 공개하며 별다른 함수는 제공하지 않는다.

객체 지향 코드에서 어려운 변경은 절차적인 코드에서 쉬우며, 절차적인 코드에서 어려운 변경은 객체 지향 코드에서 쉽다.

## 디미터 법칙

모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다.
좀 더 정확히 표현하자면, "클래스 C의 메서드 f는 다음과 같은 객체의 메서드만 호출해야 한다"

- 클래스 C
- f가 생성한 객체
- f인수로 넘어온 객체
- C 인스턴스 변수에 저장된 객체

낯선 사람은 경계하고 친구랑만 놀라

### 기차 충돌 train wreck

여러 객차가 한 줄로 이어진 기차처럼 보이기 때문에 기차 충돌이라 부른다.

```java
final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath();
```

위 코드는 다음과 같이 나누는 편이 좋다.

```java
Options opts = ctxt.getOptions();
File scratchDir = opts.getScratchDir();
final String outputDir = scratchDir.getAbsolutePath();
```

위 예제가 디미터 법칙을 위반하는지 여부는 ctxt, Options, ScratchDir이 객체인지 아니면 자료구조인지에 달렸다.
객체라면 내부 구조를 숨겨야 하므로 위반한다. 자료 구조라면 디미터 법칙이 적용되지 않는다.

코드를 다음과 같이 구현했다면 디미터 법칙을 거론할 필요가 없어진다.

```java
final String outputDir = ctxt.options.scratchDir.absolutePath;
```

### 잡종 구조

절반은 객체, 절반은 자료 구조인 잡종 구조가 나온다.

### 구조체 감추기

## 자료 전달 객체

자료 구조체의 전형적인 형태는 공개 변수만 있고 함수가 없는 클래스다. 이런 자료 구조체를 때로는 자료 전달 객체`Data Transfer Object, DTO`라 한다.

### 활성 레코드

활성 레코드는 DTO의 특수한 형태다.

## 결론

객체는 동작을 공개하고 자료를 숨긴다. 그래서 기존 동작을 변경하지 않으면서 새 객체 타입을 추가하기는 쉬운 반면, 기존 객체에 새 동작을 추가하기는 어렵다. 자료 구조는 별다른 동작 없이 자료를 노출한다. 그래서 기존 자료 구조에 새 동작을 추가하기는 쉬우나, 기존 함수에 새 자료 구조를 추가하기는 어렵다.

시스템을 구현할 때, 새로운 자료 타입을 추가하는 유연성이 필요하면 객체가 더 적합하다. 다른 경우로 새로운 동작을 추가하는 유연성이 필요하면 자료 구조와 절차적인 코드가 더 적합하다. 우수한 소프트웨어 개발자는 편견 없이 이 사실을 이해해 직면한 문제에 최적인 해결책을 선택한다.

# 7. 오류 처리

page 129

여기저기 흩어진 오류 처리 코드 때문에 프로그램 논리를 이해하기 어려워진다.
우아하고 고상하게 오류를 처리하는 기법과 고려 사항 몇 가지를 소개한다.

## 오류코드보다 예외를 사용하라

오류가 발생하면 예외를 던지는 편이 낫다.

## Try-Catch-Finally 문부터 작성하라

## 미확인unchecked 예외를 사용하라

- 확인된 예외, 미확인 예외는 무엇인가...

## 예외에 의미를 제공하라

오류 메시지에 정보를 담자.

## 호출자를 고려핼 예외 클래스를 정의하라

외부 API를 사용할 때는 감싸기 기법이 최선이다. API를 감싸면 외부 라이브러리와 프로그램 사이에서 의존성이 크게 줄어든다. 나중에 다른 라이브러리로 갈아타도 비용이 적다.

## 정상 흐름을 정의하라

특수 사례 패턴, 클래스를 만들거나 객체를 조작해 특수 사례를 처리하는 방식이다.

## null을 반환하지 마라

null을 반환하는 코드는 일거리를 늘릴 뿐만 아니라 호출자에게 문제를 떠넘긴다.

## null을 전달하지 마라

대다수 프로그래밍 언어는 호출자가 실수로 넘기는 null을 적절히 처리하는 방법이 없다.

## 결론

클린 코드는 안전성도 높아야 한다. 오류 처리를 프로그램 논리와 분리하면 독립적인 추론이 가능해지며 코드 유지보수성도 크게 높아진다.

# 8. 경계

## 외부 코드 사용하기

패키지 제공자나 프레임워크 제공자는 적용성을 최대한 넓히려 한다. 더 많은 환경에서 돌아가야 더 많은 고객이 구매하니까. 반면, 사용자는 자신의 요구에 집중하는 인터페이스를 바란다. 이런 긴장으로 인해 시스템 경계에서 문제가 생길 소지가 많다.

## 경계 살피고 익히기

외부 코드를 테스트하는 편이 우리 자신을 위해 바람직하다.

외부 코드를 익히기나 통합하기 어렵다. 다르게 접근해 우리쪽 코드를 작성해 외부 코드를 호출하는 대신 먼저 간단한 테스트 케이스를 작성해 외부 코드를 익히는 학습 테스트(짐 뉴커크의 학습 테스트, 테스트 주도 개발 222-237쪽)가 있다.
학습 테스트는 프로그램에서 사용하려는 방식대로 외부 API를 호출한다. 통제된 환경에서 API를 제대로 이해하는지 확인하는 셈이다.

## log4j 익히기

## 학습 테스트는 공짜 이상이다

학습 테스트는 이해도를 높여주는 정확한 실험이다. 투자하는 노력보다 얻는 성과가 더 크다. 패키지 새 버전이 나온다면 학습 테스트를 돌려 차이가 있는지 확인한다.
이런 경계 테스트가 있다면 패키지의 새 버전으로 이전하기 쉬워진다. 그렇지 않다면 낡은 버전을 필요 이상으로 오랫동안 사용하려는 유혹에 빠지기 쉽다.

## 아직 존재하지 않는 코드를 사용하기

때로는 모르는 코드 영역도 있다. 그 경계에 가끔은 부딪힌다. 경계 너머를 내다보기 어려웠지만, 점차로 우리에게 필요한 경계 인터페이스가 무엇인지 알게된다.
원하는 기능을 정의하고 자체적으로 인터페이스를 정의할 수 있다. 우리가 바라는 인터페이스를 구현하면 전적으로 통제한다는 장점이 생긴다. 또한 코드 가독성도 높아지고 코드 의도도 분명해진다.

## 깨끗한 경계

경계에 위치하는 코드는 깔끔히 분리한다. 또한 기대치를 정의하는 테스트 케이스도 작성한다.

# 9. 단위 테스트

## TDD 법칙 세 가지

## 깨끗한 테스트 코드 유지하기

### 테스트는 유연성, 유지보수성, 재사용성을 제공한다

## 깨끗한 테스트 코드

### 도메인에 특화된 테스트 언어

### 이중 표준

## 테스트 당 assert 하나

### 테스트 당 개념 하나

## F.I.R.S.T

Fast 빠르게: 테스트는 빨리 돌아야 한다. 자주 돌릴 수 있도록.

Independent 독립적으로: 각 테스트가 서로 의존하면 안 된다.

Repeatable 반복 가능하게: 테스트는 어떤 환경에서도 반복 가능해야 한다. 실제 환경, QA환경, 버스에서(네트워크x) 노트북 환경에서도 실행할 수 있어야 한다.

Self-Validating 자가 검증하는: 테스트는 bool 값으로 결과를 내야 한다. 성공 아니면 실패다.

Timely 적시에: 테스트는 적시에 작성해야 한다. 단위 테스트는 테스트하려는 실제 코드를 구현하기 직전에 구현한다.

## 결론

테스트 코드는 실제 코드 만큼이나 프로젝트 건강에 중요하다. 테스트 코드는 실제 코드의 유연성, 유지보수성, 재사용성을 보존하고 강화하기 때문이다. 그러므로 테스트 코드는 지속적으로 깨끗하게 관리하자.

# 10. 클래스

자바 관례에 따르면 클래스를 정의할 때 아래의 순서로 나온다.

1. 변수 목록(정적 공개 상수 - 정적 비공개 변수 - 비공개 인스턴스 변수)
1. 공개 함수
1. 비공개 함수(자신 호출하는 공개 함수 직후)
   추상화 단계가 순차적으로 내려가서 신문 기사처럼 읽힌다.

## 클래스 체계

결합도를 최소로 줄이면 자연스럽게 또 다른 클래스 설계 원칙인 DIP`Dependency Inversion Principle`를 따르는 클래스가 나온다. 본질적으로 DIP는 클래스가 상세한 구현이 아니라 추상화에 의존해야 한다는 원칙이다.

### 캡슐화

캡슐화를 풀어주는 결정은 언제나 최후의 수단이다.

## 클래스는 작아야 한다!

함수와 마찬가지다.

클래스 이름은 해당 클래스 책임을 기술해야 한다. 작명은 클래스 크기를 줄이는 첫 번째 관문이다.

### 단일 책임 원칙

클래스나 모듈을 변경할 이유가 단 하나뿐이어야 한다는 원칙이다.

도구 상자를 어떻게 관리하고 싶은가? 작은 서랍을 많이 두고 기능과 이름이 명확한 컴포넌트를 나눠 넣고 싶은가? 아니면 큰 서랍 몇 개를 두고 모두를 던져 넣고 싶은가?

### 응집도Cohesion

클래스는 인스턴스 변수 수가 작아야 한다. 각 클래스 메서드는 클래스 인스턴스 변수를 하나 이상 사용해야 한다. 일반적으로 메서드가 변수를 더 많이 사용할수록 메서드와 클래스는 응집도가 더 높다.

때때로 몇몇 메서드만이 사용하는 인스턴스 변수가 아주 많아진다. 이는 십중팔구 새로운 클래스로 쪼개야 한다는 신호다. 응집도가 높아지도록 변수와 메서드를 적절히 분리해 새로운 클래스 두세 개로 쪼개준다.

### 응집도를 유지하면 작은 클래스 여럿이 나온다

큰 함수를 작은 함수 여럿으로 쪼개다 보면 종종 작은 클래스 여럿으로 쪼갤 기회가 생긴다. 그러면서 프로그램에 점점 더 체계가 잡히고 구조가 투명해진다.

## 변경하기 쉬운 클래스

OCP란 클래스는 확장에 개방적으고 수정에 폐쇄적이어야 한다는 원칙이다.

새 기능을 수정하거나 기존 기능을 변경할 때 건드릴 코드가 최소인 시스템 구조가 바람직하다.

이상적인 시스템이라면 새 기능을 추가할 때 시스템을 확장할 뿐 기존 코드를 변경하지 않는다.

### 변경으로부터 격리

테스트가 가능할 정도로 시스템의 결합도를 낮추면 유연성과 재사용성도 더욱 높아진다. 결합도가 낮다는 소리는 각 시스템 요소가 다른 요소로부터 그리고 변경으로부터 잘 격리되어 있다는 의미다. 시스템 요소가 서로 잘 격리되어 있으면 각 요소를 이해하기도 더 쉬워진다.

좀 더 차원 높은 단계까지 신경 써보자.

# 11. 시스템

"복잡성은 죽음이다. 개발자에게서 생기를 앗아가며, 제품을 계획하고 제작하고 테스트하기 어렵게 만든다."

- Ray Ozzie, MS CTO

## 도시를 세운다면?

도시가 돌아가는 이유 중 하나는 적절한 추상화와 모듈화 때문이다. 그래서 큰 그림을 이해하지 못할지라도 개인과 개인이 관리하는 '구성요소'는 효율적으로 돌아간다.

흔히 소프트웨어 팀도 도시처럼 구성한다. 그런데 막상 팀이 제작하는 시스템은 비슷한 수준으로 관심사를 분리하거나 추상화를 이뤄내지 못한다. 깨끗한 코드를 구현하면 낮은 추상화 수준에서 관심사를 분리하기 쉬워진다. 이 장에서는 높은 추상화 수준, 즉 시스템 수준에서도 깨끗함을 유지하는 방법을 살펴본다.

## 시스템 제작과 시스템 사용을 분리하라

제작`construction`과 사용`use`는 아주 다르다.
소프트웨어 시스템은 (애플리케이션 객체를 제작하고 의존성을 서로 '연결'하는) 준비 과정과 (준비 과정 이후에 이어지는) 런타임 로직을 분리해야 한다.

시작 단계는 모든 애플리케이션이 풀어야 할 관심사`concern`다. 이것이 이 장에서 우리가 맨 처음 살펴볼 관심사다.
관심사 분리는 우리 분야에서 가장 오래되고 가장 중요한 설계 기법 중 하나다.

불행히도 대다수 애플리케이션은 시작 단계라는 관심사를 분리하지 않는다.

체계적이고 탄탄한 시스템을 만들고 싶다면 흔히 쓰는 좀스럽고 손쉬운 기법으로 모듈성을 깨서는 절대로 안된다.

### Main 분리

시스템 생성과 사용을 분리하는 한 가지 방법
생성과 관련한 코드는 모두 main이나 main이 호출하는 모듈로 옮기고, 나머지 시스템은 모든 객체가 생성되었고 모든 의존성이 연결되었다고 가정한다.

### 팩토리

때로는 객체가 생성되는 시점을 애플리케이션이 결정할 필요도 생긴다.

### 의존성 주입

사용과 제작을 분리하는 강력한 메커니즘 하나가 의존성 주입`Dependency Injection`이다. 의존성 주입은 제어 역전`Inversion of Control` 기법을 의존성 관리에 적용한 메커니즘이다.

## 확장

처음부터 올바르게 시스템을 만들 수 있다는 믿음은 미신이다. 대신에 우리는 오늘 주어진 사용자 스토리에 맞춰 시스템을 구현해야 한다. 내일은 새로운 스토리에 맞춰 시스템을 조정하고 확장하면 된다. 이것이 반복적이고 점진적인 애자일 방식의 핵심이다. 테스트 주도 개발, 리팩터링, 깨끗한 코드는 코드 수준에서 시스템을 조정하고 확장하기 쉽게 만든다.  
소프트웨어 시스템은 물리적인 시스템과 다르다. 관심사를 적절히 분리해 관리 한다면 소프트웨어 아키텍처는 점진적으로 발전할 수 있다.

### 횡단(cross-cutting) 관심사

## 자바 프록시

## 순수 자바 AOP 프레임워크

## AspectJ 관점

## 테스트 주도 시스템 아키텍처 구축

## 의사 결정을 최적화하라

## 명백한 가치가 있을 때 표준을 현명하게 사용하라

표준을 사용하면 아이디어와 컴포넌트를 재사용하기 쉽고, 적절한 경험을 가진 사람을 구하기 쉬우며, 좋은 아이디어를 캡슐화하기 쉽고, 컴포넌트를 엮기 쉽다. 하지만 떄로는 표준을 만드는 시간이 너무 오래 걸려 업계가 기다리지 못한다. 어떤 표준은 원래 표준을 제정한 목적을 잊어버리기도 한다.

## 시스템은 도메인 특화 언어가 필요하다

도메인 특화 언어(Domain-Specific Language, DSL)를 사용하면 고차원 정책에서 저차원 세부사항에 이르기까지 모든 추상화 수준과 모든 도메인을 POJO`Plain Old Java Object`로 표현할 수 있다.

## 결론

깨끗하지 못한 아키텍처는 도메인 논리를 흐리며 기민성을 떨어뜨린다. 도메인 논리가 흐려지면 제품 품질이 떨어진다.
시스템을 설계하든 개별 모듈을 설계하든, 실제로 돌아가는 가장 단순한 수단을 사용해야 한다는 사실을 명심하자.

# 12. 창발성

## 창발적 설계로 깔끔한 코드를 구현하자

우리들 대다수는 켄트 벡이 제시한 단순한 설계 규칙 네 가지가 소프트웨어 설계 품질을 크게 높여준다고 믿는다.
켄트 벡은 다음 규칙을 따르면 설계는 '단순하다'고 말한다.

- 모든 테스트를 실행한다
- 중복을 없앤다
- 프로그래머 의도를 표현한다
- 클래스와 메서드 수를 최소로 줄인다

위 목록은 중요도 순이다.

## 단순한 설계 규칙 1:모든 테스트를 실행하라

테스트가 불가능한 시스템은 검증도 불가능하다. 검증이 불가능한 시스템은 절대 출시하면 안된다.
테스트가 가능한 시스템을 만들려고 애쓰면 설계 품질이 더불어 높아진다.

## 단순한 설계 규칙 2~4: 리팩터링

리팩터링 단계에서는 소프트웨어 설계 품질을 높이는 기법이라면 무엇이든 적용해도 괜찮다. 응집도를 높이고, 결합도를 낮추고, 관심사를 분리하고, 시스템 관심사를 모듈로 나누고, 함수와 클래스 크기를 줄이고, 더 나은 이름을 선택하는 등 다양한 기법을 동원한다.

## 중복을 없애라

중복은 추가 작업, 추가 위험, 불필요한 복잡도를 뜻한다.

## 표현하라

좋은 이름을 선택한다.
함수와 클래스 크기를 가능한 줄인다.
표준 명칭을 사용한다.
단위 테스트 케이스를 꼼꼼히 작성한다.
노력한다.

## 클래스와 메서드 수를 최소로 줄여라

목표는 함수와 클래스 크기를 작게 유지하면서 동시에 시스템 크기도 작게 유지하는 데 있다.

## 결론

이 책에서 소개하는 기법은 저자들이 수십 년 동안 쌓은 경험의 정수다.

# 13. 동시성

## 동시성이 필요한 이유?

### 미신과 오해

## 난관

## 동시성 방어 원칙

### 단일 책임 원칙Single Responsibility Principle, SRP

### 따름 정리corollary: 자료 범위를 제한하라

### 따름 정리: 자료 사본을 사용하라

### 따름 정리: 스레드는 가능한 독립적으로 구현하라

## 라이브러리를 이해하라

### 스레드 환경에 안전한 컬렉션

## 실행 모델을 이해하라

### 생산자-소비자Producer-Consumer

### 읽기-쓰기Readers-Writers

### 식사하는 철학자들Dining Philosophers

## 동기화하는 메서드 사이에 존재하는 의존성을 이해하라

## 동기화하는 부분을 작게 만들어라

## 올바른 종료 코드는 구현하기 어렵다

## 스레드 코드 테스트하기

### 말이 안되는 실패 잠정적인 스레드 문제로 취급하라

### 다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들자

### 다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있게 스레드 코드를 구현하라

### 다중 스레드를 쓰는 코드 부분을 상황에 맞게 조율할 수 있게 작성하라

### 프로세서 수보다 많은 스레드를 돌려보라

### 다른 플랫폼에서 돌려보라

### 코드에 보조 코드instrument를 넣어 돌려라. 강제로 실패를 일으키게 해보라

### 직접 구현하기

### 자동화

## 결론

# 14. 점진적인 개선

## Args 구현

### 어떻게 짰느냐고?

## Args: 1차 초안

### 그래서 멈췄다

### 점진적으로 개선하다

## String 인수

## 결론

# 15. JUnit 들여다보기

## JUnit 프레임워크

## 결론

# 16. SerialDate 리팩터링

## 첫째, 돌려보자

## 둘째, 고쳐보자

## 결론

# 17. 냄새와 휴리스틱

## 주석

### C1: 부적절한 정보

### C2: 쓸모 없는 주석

### C3: 중복된 주석

### C4: 성의 없는 주석

### C5: 주석 처리된 코드

## 환경

### E1: 여러 단계로 빌드해야 한다

### E2: 여러 단계로 테스트해야 한다

## 함수

### F1: 너무 많은 인수

### F2: 출력 인수

### F3: 플래그 인수

### F4: 죽은 함수

## 일반

### G1: 한 소스 파일에 여러 언어를 사용한다

### G2: 당연한 동작을 구현하지 않는다

### G3: 경계를 올바로 처리하지 않는다

### G4: 안전 절차 무시

### G5: 중복

### G6: 추상화 수준이 올바르지 못하다

### G7: 기초 클래스가 파생 클래스에 의존한다

### G8: 과도한 정보

### G9: 죽은 코드

### G10: 수직 분리

### G11: 일관성 부족

### G12: 잡동사니

### G13: 인위적 결합

### G14: 기능 욕심

### G15: 선택자 인수

### G16: 모호한 의도

### G17: 잘못 지운 책임

### G18: 부적절한 static 함수

### G19: 서술적 변수

### G20: 이름과 기능이 일치하는 함수

### G21: 알고리즘을 이해하라

### G22: 논리적 의존성은 물리적으로 드러내라

### G23: If/Else 혹은 Switch/Case 문보다 다형성을 사용하라

### G24: 표준 표기법을 따르라

### G25: 매직 숫자는 명명된 상수로 교체하라

### G26: 정확하라

### G27: 관례보다 구조를 사용하라

### G28: 조건을 캡슐화하라

### G29: 부정 조건은 피하라

### G30: 함수는 한 가지만 해야 한다

### G31: 숨겨진 시간적인 결함

### G32: 일관성을 유지하라

### G33: 경계 조건을 캡슐화하라

### G34: 함수는 추상화 수준을 한 단계만 내려가야 한다

### G35: 설정 정보는 최상위 단계에 둬라

### G36: 추이적 탐색을 피하라

## 자바

### J1: 긴 import 목록을 피하고 와일드카드를 사용하라

### J2: 상수는 상속하지 않는다

### J3: 상수 대 Enum

## 이름

### N1: 서술적인 이름을 사용하라

### N2: 적절한 추상화 수준에서 이름을 선택하라

### N3: 가능하다면 표준 명명법을 사용하라

### N4: 명확한 이름

### N5: 긴 범위는 긴 이름을 사용하라

### N6: 인코딩을 피하라

### N7: 이름으로 부수 효과를 설명하라

## 테스트

### T1: 불충분한 테스트

### T2: 커버리지 도구를 사용하라!

### T3: 사소한 테스트를 건너뛰지 마라

### T4: 무시한 테스트는 모호함을 뜻한다

### T5: 경계 조건을 테스트하라

### T6: 버그 주변은 철저히 테스트하라

### T7: 실패 패턴을 살펴하

### T8: 테스트 커버리지 패턴을 살펴하

### T9: 테스트는 빨라야 한다

## 결론

# 부록 A 동시성 2

# 부록 B org.jfree.date.SerialDate

# 부록 C 휴리스틱의 교차 참조 목록
